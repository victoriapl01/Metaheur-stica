# -*- coding: utf-8 -*-
"""Knapsack.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/117-3HPaM-pynIPJNsg9sm6cEB86WDQEv
"""

import numpy as np
import random
import os

def leer_datos(carpeta_datos):
    carpeta = carpeta_datos
    
    # Leer capacity.txt
    capacidad_file = os.path.join(carpeta, "capacity.txt")
    capacidad = np.loadtxt(capacidad_file, dtype=int).tolist()
    
    # Leer optimalSolution.txt
    soloptima_file = os.path.join(carpeta, "optimalSolution.txt")
    soloptima = np.loadtxt(soloptima_file, dtype=int).tolist()
    
    # Leer profits.txt
    precios_file = os.path.join(carpeta, "profits.txt")
    precios = np.loadtxt(precios_file, dtype=int).tolist()
    
    # Leer weights.txt
    pesos_file = os.path.join(carpeta, "weights.txt")
    pesos = np.loadtxt(pesos_file, dtype=int).tolist()
    
    return pesos, precios, capacidad, soloptima

def evaluarSolucion(solucion, precios, pesos, pesoMax):
    precio = 0
    peso = 0
    for i in range(len(solucion)):
        precio += precios[i]*solucion[i]
        peso += pesos[i]*solucion[i]

    if peso > pesoMax:
        return 0
    else:
        return precio

def aplicarOperadoresGeneticos(poblacion, k, cProb, mProb):
    padres = []
    print(len(poblacion))
    print('POBLACION INICIAL')
    print(poblacion)


    #Seleccionar padres mediante torneo tamaño k
    print ('                    ')
    print ('                    ')
    print ('                    ')
    print('SELECCIÓN PADRES MEDIANTE TORNEO')
    print ('                    ')

    while len(padres) < len(poblacion):           #Queremos conseguir el mismo número
        selecAleatoria = []       
        i = 0
        
        while i < k:    #Selección de k números aleatorios
            j = random.randint(0, len(poblacion) - 1)   #Número aleatorio para acceder a la posición de poblacion
            #print('J es igual a '+str(j))
            if poblacion[j] not in selecAleatoria:      # Comprueba que dicho elemento no esté en la selección Aleatoria
                selecAleatoria.append(poblacion[j])       
                #print('Poblacion[j]='+str(poblacion[j]))
                i += 1
        selecAleatoria.sort(key=lambda x: x[1], reverse=True) #Ordena de mayor a menor el segundo elemento de selección Aleatoria(valor)
        #print('Ordenacion... '+str(selecAleatoria))
        #print('selecAleatoria:', selecAleatoria)
        #print('padres:', padres)
        if len(padres) % 2 != 0:                        #Las parejas no pueden ser el mismo individuo
            if selecAleatoria[0] == padres[-1]:         #El mejor individuo = ultimo de padres -> NADA
              print('LA PAREJA NO PUEDE SER EL MISMO INDIVIDUO'+str(selecAleatoria[0])+str(padres[-1]))
              pass
            else: 
              padres.append(selecAleatoria[0])
        else:
            padres.append(selecAleatoria[0])
    print ('                    ')            
    print('Población tras la selección:')
    print(padres)

    print ('                    ')
    print ('                    ')
    print ('                    ')
    print('CRUCE DE PAREJAS')
    print ('                    ')
    #Cruzar padres con probabilidad cProb
    # #if random.random() <= cProb:
    
    #EN UN SOLO PUNTO
    for i in range(0, len(padres), 2):                      #Desde 0 hasta lenpadres de 2en2       
      if random.random() <= cProb:  #Probabilidad de que se realice el cruce y se renueve la poblacion
        if i+1 < len(padres):    
          puntoCruce = random.randint(0, len(padres[i][0])-1)   #Punto aleatorio donde se realiza el cruce
          print('Punto cruce: '+str(puntoCruce))                                    
          print('Padre1 -> '+str(padres[i][0]))             
          print('Padre2 -> '+str(padres[i+1][0]))       
          hijo1 = padres[i][0][:puntoCruce] + padres[i+1][0][puntoCruce:]       #Cruce hijo 1
          print('Hijo1->'+str(hijo1))
          hijo2 = padres[i+1][0][:puntoCruce] + padres[i][0][puntoCruce:]       #Cruce hijo 2
          print('Hijo2->'+str(hijo2))
          print ('--------------')
          poblacion[i] = [hijo1]                            #Renovacion de poblacion
          poblacion[i+1] = [hijo2]                          #Renovacion de poblacion                
        else:           #Si la población es impar el ultimo individuo se mantiene igual
          poblacion[i] = [padres[i][0],]  #La población debe estar sin evaluar
      else:        #Probabilidad de que no se realice el cruce 
        if i+1 < len(padres):   #NO se renueva la población, se mantiene
          poblacion[i] = [padres[i][0],]  #
          poblacion[i+1] = [padres[i+1][0],]
        else:
          poblacion[i] = [padres[i][0],]


    print ('                    ')
    print ('                    ')
    print ('                    ')
    print('MUTACIÓN DE INDIVIDUOS')
    print ('                    ')

    #Mutar padres con probabilidad mProb
    #if random.random(0,1) <= mProb:
    for i in range(len(poblacion)):
        if random.random() <= mProb:  # Probabilidad de mutar
            gen_mutado = random.randint(0, len(poblacion[i][0]) - 1)  # Seleccionar gen aleatorio para mutar
            print('Gen Mutado '+str(gen_mutado+1))
            #Modificacion del gen_mutado
            print('Individuo sin mutar -> '+str(poblacion[i]))
            if poblacion[i][0][gen_mutado] == 0:
              poblacion[i][0][gen_mutado] = 1
              print('Individuo mutado -> '+str(poblacion[i]))
            else:
              poblacion[i][0][gen_mutado] = 0 
              print('Individuo mutado -> '+str(poblacion[i]))
            print ('--------------')

    print ('                    ')
    print ('                    ')
    print ('                    ')
    print('MEDIDA DE LA POBLACION FINAL '+str(len(poblacion)))
    print('LA POBLACION FINAL SIN EVALUAR')
    print(poblacion)
    return poblacion #Devolver la nueva poblacion (sin evaluar)

import random
import numpy as np


def main():
    datos = leer_datos('5')
    pesos = datos[0]
    precios = datos[1]
    pesoMax = datos[2] #Peso máximo que se puede poner en la mochila
    solOptima=datos[3]
    nSoluciones = 25 #Tamaño de la poblacion
    maxGeneraciones = 10 #Numero de generaciones
    k = 3 #Tamaño torneo selector de padres
    cProb = 0.7 #Probabilidad de cruce
    mProb = 0.1 #Probabilidad de mutacion

    l=len(pesos)
    ##Creamos n soluciones aleatorias que sean válidas
    poblacion = []
    for i in range(nSoluciones):
        objetos = list(range(l))
        solucion = []
        peso = 0
        while peso < pesoMax:
            objeto = objetos[random.randint(0, len(objetos) - 1)]
            peso += pesos[objeto]
            if peso <= pesoMax:
                solucion.append(objeto)
                objetos.remove(objeto)

        s = []
        for i in range(l):
            s.append(0)
        for i in solucion:
            s[i] = 1
        poblacion.append([s,evaluarSolucion(s,precios,pesos,pesoMax)])

    it=0
    while it < maxGeneraciones:
        nSoluciones = aplicarOperadoresGeneticos(poblacion,k,cProb,mProb)
        #Modelo generacional
        poblacion = []
        for solucion in nSoluciones:
            poblacion.append([solucion[0],evaluarSolucion(solucion[0],precios,pesos,pesoMax)])
        it+=1
      
    print('POBLACIÓN FINAL EVALUADA')
    print(poblacion)

    print ('                    ')
    print ('                    ')
    print ('                    ')
    print('SOLUCIÓN MEJOR OBTENIDA DEL ALGORITMO: ')
    poblacion.sort(key=lambda x: x[1], reverse=True) #Ordena de mayor a menor el segundo elemento de poblacion(valor)
    print(poblacion[0])
    print('SOLUCIÓN ÓPTIMA REAL')
    print(solOptima)

if __name__ == "__main__":
    main()

